<html>
  <head>
    <meta charset="UTF-8">

    <link rel="stylesheet" href="opensans_regular_macroman/stylesheet.css" type="text/css" charset="utf-8" />

    <link rel="stylesheet" href="styles.css" type="text/css" charset="utf-8" />

    <script type="text/javascript">
      mxBasePath = 'mxgraph/src';
    </script>
    <script src="mxgraph/mxClient.min.js"></script>

    <style>
      #content {
      padding: 0 0 0 20;
      }
    </style>

  </head>

  <body>
    <div id="navbar">
      <ul>
	<li><a class="active" href="index.html">Home</a></li>
	<!--<li><a href="definitions.html">Definitions</a></li>-->
	<!--<li><a href="proofs_index.html">Proofs</a></li>-->
      </ul>
    </div>

    <div id="content">
      <h4>Goldreich-Goldwasser-Micali: Building PRFs from PRGs</h4>
      <p>
      Pseudorandom generators (PRGs) deterministically expand a (short) truly uniformly
      random bitstring x into a longer <b>pseudo</b>random bitstring y. Since Cryptography 
      very much relies on things that look random but actually aren't, this ability to
      generate pseudorandomness is key in many contexts. While PRGs are useful, pseudorandom
      functions (PRFs) (a.k.a. stream ciphers) are exponentially more useful, because two parties who share a
      short uniformly random key k now share indeed <b> exponentially</b> many random strings, because a PRF
      can be evaluated on k and any string x, yielding values which look independently
      uniformly random to anyone who does not have any information about k. 
      </p>
      <p>
      While PRFs seem much more powerful than PRGs, 
      <a href="https://www.wisdom.weizmann.ac.il/~oded/ggm.html">
      Goldreich, Goldwasser and Micali (GGM)</a> show
      that arranging a length-doubling PRG into a tree allows to build a PRF from a PRG, where
      the domain grows exponentially in the depth of the tree. When the tree is of constant depth,
      then the proof proceeds via a hybrid argument over all PRGs.
      </p>
      <p>
	    See <a href="ggm.html">here</a> for an SSP-style proof of a constant-depth GGM construction.
      </br>
      </br> 
      </p>
      <p>
      <b>Note:</b> When the tree is of super-constant depth, then the proof proceeds via a hybrid
      argument over the adversarial queries (because else, there would be exponentially many 
      game-hops). See Chapter 3, Section 3.6 of  Goldreich's 
      <a href="https://www.wisdom.weizmann.ac.il/~oded/foc-book.html">Foundations of Cryptography I</a> 
      for a proof for the case of superconstant depth.
      </p>
    </div>
  </body>
</html>
